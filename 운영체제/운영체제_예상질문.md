- **프로세스와 스레드란?**
  - 프로세스는 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케줄링의 대상이 되는 작업
  - 스레드는 `프로세스 내 작업의 흐름`으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
  - 프로세스와 스레드 차이
    - 스레드는 스택을 제외한 메모리를 공유하기 때문에 스레드 간 데이터 공유와 통신이 프로세스에 비해 더 효율적입니다.
    - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
    - 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, Inter-Process Communication)을 사용해야 한다.
      예) 파이프, 파일, 소켓 등을 이용한 통신 방법
    - 프로세스 자원 공유는 단순히 CPU 레지스터 교체뿐만이 아니라 RAM과 CPU 사이의 캐시 메모리까지 초기화되기 때문에 자원 부담이 크다는 단점이 있다. 그래서 다중 작업이 필요한 경우 스레드를 이용하는 것이 훨씬 효율적이라 현대 컴퓨터의 운영체제에선 다중 프로세싱을 지원하고 있지만 다중 스레딩을 기본으로 하고 있다.
- **프로세스의 상태에 대해 설명해보세요.**
  **이 답변은 그림을 보면서 본인이 flow를 설명할 수 있어야 함 !!!!!!!!**
  `생성` 최초로 프로세스가 만들어진 상태
  `대기` (메모리 있을 때)
  `대기 중단` (메모리 없을 때)
  `실행` (메모리도, CPU도 모두 할당 받을 때)
  `중단` (I/O가 필요할 때) - ASLEEP 상태.
  `일시 중단` (메모리 없을 때)
  ![Untitled](https://github.com/chloe73/TIL/assets/50287759/76cb9df5-074d-43cd-bb55-349004b5e7df)
  **기본**
  ![Untitled2](https://github.com/chloe73/TIL/assets/50287759/ae6e6a65-6b6d-4eae-a0d9-4f18b6956d53)
  **상세(지연 상태 표시)**
  ### 생성 상태 (create)
  - 프로세스가 생성된 상태를 의미
  - fork() 또는 exec() 함수를 통해 생성함
  - 이때 PCB가 할당
  ### 대기 상태 (ready)
  - 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태
  ### 대기 중단 상태 (ready suspended)
  - 대기 중단 상태는 메모리 부족으로 일시 중단된 상태
  ### 실행 상태 (running)
  - 실행 상태는 CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태를 의미
  - 이를 CPU burst가 일어났다고도 표현
  ### 중단 상태 (blocked)
  - 중단 상태는 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
  - I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 함
  - 예를 들어 프린트 인쇄 버튼을 눌렀을 때 프로세스가 잠깐 멈춘 듯할 때가 바로 그 상태
  ### 일시 중단 상태 (blocked suspended)
  - 일시 중단 상태는 대기 중단과 유사
  - 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태
  ### 종료 상태 (terminated)
  - 종료 상태는 메모리와 CPU 소유권을 모두 놓고 가는 상태
  - 종료는 자연스럽게 종료되는 것도 있지만 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료(abort)로 종료되는 것도 있음
  - 자식 프로세스에 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process.kill 등 여러 명령어로 프로세스를 종료할 때 발생
- **프로세스의 메모리 구조에 대해 설명해보세요.**
  프로세스의 메모리 구조는 동적 영역과 정적 영역으로 나눕니다. 스택과 힙은 동적 할당이 되며 런타임 단계에서 메모리를 할당 받는 것을 의미합니다. 데이터 영역과 코드 영역은 정적 할당이 되며 컴파일 단계에서 메모리를 할당 받습니다.
  <img width="875" alt="img3" src="https://github.com/chloe73/TIL/assets/50287759/eafa2034-d94f-43a6-ae69-780070e93af5">
  <img width="340" alt="img4" src="https://github.com/chloe73/TIL/assets/50287759/1c3987ec-2744-46f6-b240-92f37c88293d">
  - 프로세스는 스택, 힙, 데이터 영역, 코드 영역으로 나눠져 있음
  - 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당됨
  ### 스택
  - 스택에는 지역변수, 매개변수, 함수가 저장되고 ~~컴파일 시에 초기 크기가 결정될 수 있으~~**며** ‘동적’인 특징을 갖는다. **메모리 할당은 런타임시에 결졍된다.**
  - 스택 영역은 함수가 함수를 재귀적으로 호출하면서 **동적으로 크기가 늘어날 수 있는데**, 이때 힙과 스택의 메모리 영역이 겹치면 안 되기 때문에 힙과 스택 사이의 공간을 비워 놓는다.
  ### 힙
  - 힙은 동적 할당할 때 사용되며 **런타임 시 크기가 결정**된다.
  - 예를 들어 벡터 같은 동적 배열은 당연히 힙에 동적 할당된다.
  - 힙은 ‘동적’인 특징을 가짐.
  ### 데이터 영역
  - 데이터 영역은 전역변수, 정적변수가 저장되고, 정적인 특징을 갖는 프로그램이 종료되면 사라지는 변수가 들어있는 영역
  - 데이터 영역은 BSS 영역과 Data 영역으로 나뉘고, BSS 영역은 초기화가 되지 않은 변수가 0으로 초기화되어 저장되면 Data 영역(Data segment)은 0이 아닌 다른 값으로 할당된 변수들이 저장된다.
  ### 코드 영역
  - 코드 영역은 프로그램에 내장되어 있는 소스 코드가 들어가는 영역
  - 이 영역은 수정 불가능한 기계어로 저장되어 있으며 정적인 특징을 가짐.
- **PCB란 무엇인가요?**
  - **PCB(Process Control Block)는 운영체제에서 프로세스에 대한 메타데이터를 저장한 ‘데이터’를 말한다.**
  - **프로세스 제어 블록이라고도 함.**
  - **프로세스가 생성되면 운영체제는 PCB를 생성함.**
  - **프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 앞서 설명한 스택, 힙 등의 구조를 기반으로 메모리가 할당됨.**
  - **그리고 이 프로세스의 메타데이터들이 PCB에 저장되어 관리됨.**
  - **이는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리됨.**
  ### pcb 구조는 굳이??????
  ### PCB의 구조
  - 프로세스 스케줄링 상태
  - 프로세스 ID
  - 프로세스 권한
  - 프로그램 카운터
  - CPU 레지스터
  - CPU 스케줄링 정보
  - 계정 정보
  - I/O 상태 정보
- **컨텍스트 스위칭이란 무엇인가요?**
  - **컨텍스트 스위칭(context switching)은 PCB를 교환하는 과정을 말함.**
  - **한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생함.**
  - **컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 어떠한 시점에서 실행되고 있는 프로세스는 단 한 개이며, 많은 프로세스가 동시에 구동되는 것처럼 보이는 것은 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문이다.**
  - 참고로 현대 컴퓨터는 멀티코어의 CPU를 가지기 때문에 한 시점에 한 개의 프로그램이라는 설명은 틀린 설명이다.
  - 하지만 컨텍스트 스위칭을 설명할 때는 싱글코어를 기준으로 설명함.
    <img width="507" alt="img5" src="https://github.com/chloe73/TIL/assets/50287759/3006c03f-8ba1-4d5d-a773-0e32dcbb5f59">
    - 위의 그림처럼, 한 개의 프로세스 A가 실행하다 멈추고, 프로세스 A의 PCB를 저장하고 다시 프로세스 B를 로드하여 실행함.
    - 그리고 다시 프로세스 B의 PCB를 저장하고 프로세스 A의 PCB를 로드함.
    - 컨텍스트 스위칭이 일어날 때 위의 그림처럼 유휴 시간(idle time)이 발생하는 것을 볼 수 있음.
    - 이뿐만 아니라 이 컨텍스트 스위칭에 드는 비용이 더 있음. 바로 캐시미스이다.
    - 비용 : 캐시미스
      - 컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시클리어 과정을 겪게 되고 이 때문에 캐시미스가 발생함.
    - 스레드에서의 컨텍스트 스위칭
      - 참고로 이 컨텍스트 스위칭은 스레드에서도 일어남.
      - 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭의 경우 비용이 더 적고 시간도 더 적게 걸림.
- **뮤텍스와 세마포어에 대해 설명해보세요.**
  - 뮤텍스와 세마포어는 임계 영역을 해결하기 위한 방법 입니다.
  - 이 둘의 핵심은 락을 걸어 다른 스레드가 접근하지 못하게 하여 데이터의 일관성을 유지하는 것 입니다.
  - 뮤텍스는 공유 자원을 사용하기 전에 설정하고 사용한 후에 해제하는 잠금이다. 잠금이 설정되면 다른 스레드는 잠긴 코드 영역에 접근할 수 없다. 또한 뮤텍스는 하나의 상태(잠금 또는 잠금 해제)만 가진다.
  - 세마포어는 일반화된 뮤텍스이다. 간단한 정수 값과 두 가지 함수 wait(P 함수라고도 함) 및 signal(V 함수라고도 함)로 공유 자원에 대한 접근을 처리한다.
  ***
  (임계 영역이란 공유 자원에 여러 프로세스나 스레드가 동시 접근하여 데이터의 일관성이 손상된 영역입니다.)
  뮤텍스는 한 스레드, 프로세스에 의해 소유될 수 있는 키를 기반으로 한 상호배제기법이고,
  세마포어는 현재 공유자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법이다.
  뮤텍스는 락 매커니즘을 이용하여 공유자원에 Unlock, lock을 걸어두는 것을 의미합니다. 세마포어는 wait, signal 로 공유자원에 대한 접근을 처리합니다. wait은 자신의 차례가 올때까지 기다리는 것이고, signal은 다른 사람에게 순서를 넘겨주는 것입니다. 모니터는 공유 자원을 숨기고 해당 접근에 대한 인터페이스만 모니터 큐를 통해 제공하는 방법입니다.
  뮤텍스와 세마포어는 임계 영역을 해결하기 위한 방법이다.
  뮤텍스는 한 스레드, 프로세스에 의해 소유될 수 있는 키를 기반으로 한 상호배제기법이고,
  세마포어는 현재 공유자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법이다.
  **뮤텍스 (mutex)**
  뮤텍스는 공유 자원을 사용하기 전에 설정하고 사용한 후에 해제하는 잠금이다. 잠금이 설정되면 다른 스레드는 잠긴 코드 영역에 접근할 수 없다. 또한 뮤텍스는 하나의 상태(잠금 또는 잠금 해제)만 가진다.
  **세마포어 (semaphore)**
  세마포어는 일반화된 뮤텍스이다. 간단한 정수 값과 두 가지 함수 wait(P 함수라고도 함) 및 signal(V 함수라고도 함)로 공유 자원에 대한 접근을 처리한다.
  wait()는 자신의 차례가 올 때까지 기다리는 함수이며, signal()은 다음 프로세스로 순서를 넘겨주는 함수이다.
  ### 이해하기 쉬운 예시
  뮤텍스는 화장실이 하나밖에 없는 식당과 비슷하다. 화장실을 가기 위해서는 카운터에서 열쇠를 받아 가야 한다. 당신이 화장실을 가려고 하는데 카운터에 키가 있으면 화장실에 사람이 없다는 뜻이고 당신은 그 열쇠를 이용해 화장실에 들어갈 수 있다. 하지만 키가 없다면 아무리 용무가 급하더라도 사람이 나올때까지 카운터에서 기다려야 한다. 이것이 뮤텍스가 동작하는 방식이다. 화장실을 이용하는 사람은 프로세스 혹은 스레드이고 화장실은 공유자원, 키는 공유자원에 접근하기 위해 필요한 어떤 오브젝트이다. 즉 뮤텍스는 키에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 프로세스, 스레드만이 공유자원에 접근할 수 있다.
  세마포어는 손님이 화장실을 좀 더 쉽게 이용할 수 있는 레스토랑이다. 세마포어를 이용하는 레스토랑의 화장실에는 여러 개의 칸이 있다. 그리고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있다. 만약 당신이 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈 칸이 1개 이상이라면 빈 칸의 개수를 하나 뺀 다음에 화장실로 입장해야 한다. 그리고 나올 때 빈 칸의 개수를 하나 더해준다. 모든 칸에 사람이 들어갔을 경우 빈 칸의 개수는 0이 되며 이때 화장실에 들어가고자 하는 사람은 빈 칸의 개수가 1로 바뀔 때까지 기다려야 한다. 이처럼 세마포어는 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성한다.
- **교착 상태의 원인과 해결 방법에 대해 설명해보세요.**
  교착 상태에 원인은 4가지가 있습니다.
  상호 배제 : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스에서 접근할 수 없다.
  점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 대기
  비선점 : 다른 프로세스의 자원을 강제로 가져올 수 없음
  환형 대기 : 프로세스가 서로의 자원을 요구하는 상황
  이 4가지가 모두 충족되어야 교착 상태가 일어납니다.
  데드락 해결 방법은 예방, 회피, 탐지 및 복구로 나눌 수 있습니다. 예방은 데드락이 발생하지 않도록 설계 및 자원 할당 규칙을 변경합니다. 회피는 안전한 자원 요청 경로를 찾아 데드락을 피하거나 미리 계산된 안전 상태로만 진입합니다. 탐지 및 복구는 데드락이 발생하면 이를 탐지하고 자원을 해제하거나 프로세스를 종료하여 회복합니다.
  일반적으로 교착 상태를 해결하는 방법에는 세 가지가 있습니다.
  1. 교착 상태 예방(Prevention) 또는 회피(Avoidance)
     - 교착 상태가 되지 않도록 합니다.
     - 자원 할당 그래프 알고리즘 (Resource-Allocation Graph Algorithm)
     - 은행원 알고리즘 (Banker's Algorithm)
  2. 교착 상태 탐지(Detection) 및 복구(Recovery)
     - 교착 상태가 탐지되면 시스템에 문제가 발생하지 않도록 조치를 취합니다.
     - 대기 그래프(wait-for graph)
     - 은행원 알고리즘 (Banker's Algorithm)
  3. 교착상태 무시(Ignore)
     - 교착 상태가 정말 드물게 발생하는 경우(1년에 한번) 교착 상태 예방 또는 탐지와 관련된 지속된 오버헤드 및 성능 저하를 발생 시키는 것보다 교착 상태가 발생하도록 하고 필요에 따라 재부팅하는 것이 더 나을 수 있습니다.(Unix 및 window를 포함한 대부분의 운영체제가 사용하는 방법)
       교착 상태가 발생하면 사이클이 있는지 확인하고 하나씩 프로세스를 종료합니다.
- **CPU 스케줄링 알고리즘 비선점형 방식에 대해 설명해보세요.**
  - 비선점형 방식은 강제로 프로세스를 중지하지 않는 방식입니다.
  - 그러므로 컨텍스트 스위칭에 의한 부하가 적습니다.
  - 알고리즘에 따라 순서를 부여되고 그 순서대로 프로세스에 CPU를 할당합니다.
  - FCFS, SJF, 우선순위 등의 예시가 있습니다.
  ***
  - CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 할 일을 스레드로 CPU에 할당합니다.
- **CPU 스케줄링 알고리즘 선점형 방식에 대해 설명해보세요.**
  선점형 방식은 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식 입니다.
  현대 운영체제에서는 선점형 방식을 사용하고 있습니다.
  라운드 로빈, SRF, 다단계 큐 등이 있습니다.
  ***
  <img width="642" alt="img6" src="https://github.com/chloe73/TIL/assets/50287759/c70fae4b-214f-4a9f-bd0d-77fdfe6a067e">
  <img width="610" alt="img7" src="https://github.com/chloe73/TIL/assets/50287759/a5c55c77-c065-4fd6-90b1-bee774a7f9d0">
  <img width="614" alt="img8" src="https://github.com/chloe73/TIL/assets/50287759/b287a443-35b9-4f03-a396-aa215679bcb1">
