## JavaScript 면접 대비

- [클로저](#✔️-자바스크립트-클로저)
- [호이스팅](#✔️-호이스팅)
- [CORS 에러](#✔️-cors-에러)

### ✔️ 자바스크립트 클로저

- 함수와 그 함수가 선언된 렉시컬 환경의 조합이다. 클로져는 함수 내부에서 정의된 함수가 외부 함수의 변수에 접근할 수 있는 현상을 나타낸다.

- 클로저를 사용하여 비동기 작업에서 변수의 상태를 보존하거나, 모듈 패턴을 구현하여 private 변수를 만들 수 있다.

```javascript
function makeFunc() {
  const name = "Mozilla";
  function displayName() {
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();
```

1. 내부 함수가 외부 함수의 변수에 접근할 수 있습니다: 외부 함수의 변수가 내부 함수에 의해 참조되면, 해당 변수는 클로저에 포함됩니다. 이로써 내부 함수는 외부 함수의 변수를 계속해서 사용할 수 있습니다.
2. 클로저는 외부 함수의 실행 컨텍스트를 기억합니다: 외부 함수가 반환된 이후에도 클로저는 여전히 외부 함수의 변수에 접근할 수 있습니다. 이는 외부 함수의 실행 컨텍스트가 클로저에 의해 유지되기 때문입니다.
3. 클로저는 private 변수를 구현하는 데 사용될 수 있습니다: 클로저를 활용하면 변수를 외부에서 직접 접근할 수 없도록 보호할 수 있습니다. 이를 통해 정보 은닉과 캡슐화를 구현할 수 있습니다.

---

### ✔️ 호이스팅

- 호이스팅은 변수를 선언하고 초기화했을 때, 선언 부분이 최상단으로 끌어올려지는 현상을 말한다.
- var의 경우 변수를 선언하고 초기화하는 과정이 동시에 일어나서 호이스팅이 발생한다.
- 반면 let/const 의 경우 선언과 초기화 단계가 동시에 일어나지 않는다.
- 실행 시점에서 실제 선언부를 만날 때 초기화가 이뤄진다.

자바스크립트 호이스팅(Hoisting)은 자바스크립트에서 변수 및 함수 선언이 스코프의 상단으로 "끌어올려지는" 동작을 말합니다. 즉, 코드 내에서 변수 및 함수 선언이 실제로 작성된 위치와 상관없이 선언이 스코프의 최상단으로 옮겨지는 것처럼 동작합니다.

호이스팅은 두 가지 주요 요소에 적용됩니다:

1. 변수 호이스팅: 변수 선언(var, let, const)은 해당 스코프의 상단으로 호이스팅됩니다. 이는 변수 선언부가 실제 코드의 위치보다 앞서 실행된다는 의미입니다. 그러나 변수의 할당(초기화) 부분은 호이스팅되지 않으며, 실제 코드 위치에 따라 실행됩니다. 이로 인해 변수를 선언하기 전에 사용하는 경우에도 에러가 발생하지 않습니다. 변수는 undefined로 초기화되며, 할당은 해당 라인에서 이루어집니다.
2. 함수 호이스팅: 함수 선언식(function declaration)은 해당 스코프의 상단으로 호이스팅됩니다. 함수 선언식은 변수 선언과 동일하게 스코프의 최상단으로 올라갑니다. 이는 함수를 선언하기 전에 호출해도 정상적으로 작동한다는 것을 의미합니다.

예를 들어, 다음과 같은 코드를 고려해 봅시다:

```js
console.log(x); // undefined
var x = 5;

foo(); // "Hello!"
function foo() {
  console.log("Hello!");
}
```

위의 코드는 호이스팅이 적용되는 예입니다. 변수 `x`와 함수 `foo`의 선언이 해당 스코프의 최상단으로 올라갑니다. 따라서 `console.log(x)`는 변수가 선언되었지만 초기화되지 않았으므로 `undefined`를 출력하고, `foo()`는 함수가 선언되었으므로 정상적으로 실행되어 "Hello!"를 출력합니다.

호이스팅은 코드를 더욱 이해하기 어렵게 만들 수 있으므로, 변수와 함수를 코드 상단에서 선언하는 것을 권장합니다. 또한, `let`과 `const`를 사용하여 변수를 선언하면 블록 스코프 변수를 사용할 수 있고 호이스팅 문제를 피할 수 있습니다.

---

### ✔️ CORS 에러

- CORS(Cross-Origin Resource Sharing) 에러는 웹 애플리케이션에서 발생할 수 있는 보안 정책입니다. CORS는 웹 브라우저에서 실행 중인 애플리케이션이 다른 도메인, 프로토콜 또는 포트의 리소스에 접근할 수 있는 권한을 부여하는 메커니즘입니다.

- 보통 웹 애플리케이션은 같은 도메인에서 실행되는 리소스에 자유롭게 접근할 수 있지만, 다른 도메인으로부터 리소스를 요청할 때는 보안상의 이유로 웹 브라우저가 이를 제한합니다. 이런 제한을 우회하기 위해 CORS 정책이 도입되었습니다.

- CORS 에러는 다른 도메인에 있는 리소스에 접근할 때 발생하는 문제로, 웹 애플리케이션이 리소스에 접근할 권한이 없을 때 브라우저에서 보안상의 이유로 요청을 차단하는 것입니다. 이는 웹 애플리케이션의 보안을 강화하기 위한 것입니다.

- CORS 에러를 해결하기 위해 몇 가지 방법이 있습니다.

  - 가장 일반적인 방법은 서버 측에서 올바른 CORS 헤더를 설정하는 것입니다. 서버는 클라이언트 요청에 대해 Access-Control-Allow-Origin 헤더를 포함하여 응답해야 합니다. 이 헤더는 허용된 도메인을 지정하거나 '\*'와 같은 와일드카드를 사용하여 모든 도메인에서의 접근을 허용할 수 있습니다.

  - 또한, 서버 측에서는 요청 메서드(POST, GET 등) 및 허용되는 헤더(예: Content-Type) 등에 대한 Access-Control-Allow-Methods와 Access-Control-Allow-Headers 헤더도 설정해야 합니다.

- 또 다른 해결책으로는 JSONP(JSON with Padding)나 프록시 서버를 사용하는 방법도 있습니다. 이를 통해 클라이언트 측에서 직접적으로 다른 도메인으로의 요청을 보내지 않고, 중간에 프록시 서버를 통해 요청을 전달할 수 있습니다.

- 요약하면, CORS 에러는 웹 애플리케이션이 다른 도메인의 리소스에 접근할 때 발생하는 보안 정책 문제입니다. 서버 측에서 올바른 CORS 헤더를 설정하거나 다른 해결책을 사용하여 이 문제를 해결할 수 있습니다.

---
